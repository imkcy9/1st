// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enum.proto

#ifndef PROTOBUF_enum_2eproto__INCLUDED
#define PROTOBUF_enum_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

namespace protobuf_enum_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
inline void InitDefaults() {
}
}  // namespace protobuf_enum_2eproto
namespace FIRST {
}  // namespace FIRST
namespace FIRST {

enum ConnectionStatus {
  UNINITIALISED = 0,
  INITIALIZED = 1,
  DISCONNECTED = 2,
  CONNECTING = 3,
  CONNECTED = 4,
  AUTHORIZING = 5,
  AUTHORIED = 6,
  LOGINING = 7,
  LOGINED = 8,
  CONFIRMING = 9,
  CONFIRMED = 10,
  DOING = 11,
  DONE = 12,
  CONNECTION_STATUS_UNKNOWN = 13,
  ConnectionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConnectionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConnectionStatus_IsValid(int value);
const ConnectionStatus ConnectionStatus_MIN = UNINITIALISED;
const ConnectionStatus ConnectionStatus_MAX = CONNECTION_STATUS_UNKNOWN;
const int ConnectionStatus_ARRAYSIZE = ConnectionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionStatus_descriptor();
inline const ::std::string& ConnectionStatus_Name(ConnectionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionStatus_descriptor(), value);
}
inline bool ConnectionStatus_Parse(
    const ::std::string& name, ConnectionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionStatus>(
    ConnectionStatus_descriptor(), name, value);
}
enum ApiType {
  NONE = 0,
  TRADE = 1,
  MARKET_DATA = 2,
  LEVEL2 = 4,
  QUOTE_REQUEST = 8,
  HISTORICAL_DATA = 16,
  INSTRUMENT = 32,
  QUERY = 64,
  ApiType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ApiType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ApiType_IsValid(int value);
const ApiType ApiType_MIN = NONE;
const ApiType ApiType_MAX = QUERY;
const int ApiType_ARRAYSIZE = ApiType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ApiType_descriptor();
inline const ::std::string& ApiType_Name(ApiType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ApiType_descriptor(), value);
}
inline bool ApiType_Parse(
    const ::std::string& name, ApiType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ApiType>(
    ApiType_descriptor(), name, value);
}
enum ResumeType {
  RESUME_TYPE_UNDEFINED = 0,
  RESTART = 1,
  RESUME = 2,
  QUICK = 3,
  ResumeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ResumeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ResumeType_IsValid(int value);
const ResumeType ResumeType_MIN = RESUME_TYPE_UNDEFINED;
const ResumeType ResumeType_MAX = QUICK;
const int ResumeType_ARRAYSIZE = ResumeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResumeType_descriptor();
inline const ::std::string& ResumeType_Name(ResumeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResumeType_descriptor(), value);
}
inline bool ResumeType_Parse(
    const ::std::string& name, ResumeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResumeType>(
    ResumeType_descriptor(), name, value);
}
enum LogLevel {
  TRACE = 0,
  DEBUG = 1,
  INFO = 2,
  WARN = 3,
  ERROR = 4,
  FATAL = 5,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogLevel_IsValid(int value);
const LogLevel LogLevel_MIN = TRACE;
const LogLevel LogLevel_MAX = FATAL;
const int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogLevel_descriptor();
inline const ::std::string& LogLevel_Name(LogLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogLevel_descriptor(), value);
}
inline bool LogLevel_Parse(
    const ::std::string& name, LogLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum PutCall {
  PUT = 0,
  CALL = 1,
  PutCall_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PutCall_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PutCall_IsValid(int value);
const PutCall PutCall_MIN = PUT;
const PutCall PutCall_MAX = CALL;
const int PutCall_ARRAYSIZE = PutCall_MAX + 1;

const ::google::protobuf::EnumDescriptor* PutCall_descriptor();
inline const ::std::string& PutCall_Name(PutCall value) {
  return ::google::protobuf::internal::NameOfEnum(
    PutCall_descriptor(), value);
}
inline bool PutCall_Parse(
    const ::std::string& name, PutCall* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PutCall>(
    PutCall_descriptor(), name, value);
}
enum OrderStatus {
  NOTSENT = 0,
  PENDING_NEW = 1,
  NEW = 2,
  REJECTED = 3,
  PARTIALLY_FILLED = 4,
  FILLED = 5,
  PENDING_CANCELL = 6,
  CANCELLED = 7,
  EXPIRED = 8,
  PENDING_REPLACE = 9,
  REPLACED = 10,
  OrderStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OrderStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OrderStatus_IsValid(int value);
const OrderStatus OrderStatus_MIN = NOTSENT;
const OrderStatus OrderStatus_MAX = REPLACED;
const int OrderStatus_ARRAYSIZE = OrderStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderStatus_descriptor();
inline const ::std::string& OrderStatus_Name(OrderStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderStatus_descriptor(), value);
}
inline bool OrderStatus_Parse(
    const ::std::string& name, OrderStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderStatus>(
    OrderStatus_descriptor(), name, value);
}
enum ExecType {
  EXECTYPE_NEW = 0,
  EXECTYPE_STOPPED = 1,
  EXECTYPE_REJECED = 2,
  EXECTYPE_EXPIRED = 3,
  EXECTYPE_TRADE = 4,
  EXECTYPE_PENDING_CANCEL = 5,
  EXECTYPE_CANCELLED = 6,
  EXECTYPE_CANCELL_REJECT = 7,
  EXECTYPE_PENDING_REPLACE = 8,
  EXECTYPE_REPLACE = 9,
  EXECTYPE_REPLACE_REJECT = 10,
  EXECTYPE_TRADE_CORREC = 11,
  EXECTYPE_TRADE_CANCEL = 12,
  EXECTYPE_ORDER_STATUS = 13,
  EXECTYPE_PENDING_NEW = 14,
  EXECTYPE_CLEARING_HOLD = 15,
  ExecType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExecType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExecType_IsValid(int value);
const ExecType ExecType_MIN = EXECTYPE_NEW;
const ExecType ExecType_MAX = EXECTYPE_CLEARING_HOLD;
const int ExecType_ARRAYSIZE = ExecType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecType_descriptor();
inline const ::std::string& ExecType_Name(ExecType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecType_descriptor(), value);
}
inline bool ExecType_Parse(
    const ::std::string& name, ExecType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecType>(
    ExecType_descriptor(), name, value);
}
enum OrderSide {
  BUY = 0,
  SELL = 1,
  LOF_CREATION = 2,
  LOF_REDEMPTION = 3,
  ETF_CREATION = 4,
  ETF_REDEMPTION = 5,
  MERGE = 6,
  SPLIT = 7,
  CB_CONVERT = 8,
  CB_REDEMPTION = 9,
  ORDER_SIDE_UNKNOWN = 10,
  OrderSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OrderSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OrderSide_IsValid(int value);
const OrderSide OrderSide_MIN = BUY;
const OrderSide OrderSide_MAX = ORDER_SIDE_UNKNOWN;
const int OrderSide_ARRAYSIZE = OrderSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderSide_descriptor();
inline const ::std::string& OrderSide_Name(OrderSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderSide_descriptor(), value);
}
inline bool OrderSide_Parse(
    const ::std::string& name, OrderSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderSide>(
    OrderSide_descriptor(), name, value);
}
enum OrderType {
  MARKET = 0,
  STOP = 1,
  LIMIT = 2,
  STOP_LIMIT = 3,
  MARKET_ON_CLOSE = 4,
  PEGGED = 5,
  TRAILING_STOP = 6,
  TRAILING_STOP_LIMIT = 7,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OrderType_IsValid(int value);
const OrderType OrderType_MIN = MARKET;
const OrderType OrderType_MAX = TRAILING_STOP_LIMIT;
const int OrderType_ARRAYSIZE = OrderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderType_descriptor();
inline const ::std::string& OrderType_Name(OrderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderType_descriptor(), value);
}
inline bool OrderType_Parse(
    const ::std::string& name, OrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderType>(
    OrderType_descriptor(), name, value);
}
enum TimeInForce {
  ATC = 0,
  DAY = 1,
  GTC = 2,
  IOC = 3,
  OPG = 4,
  OC = 5,
  FOK = 6,
  GTX = 7,
  GTD = 8,
  GFS = 9,
  AUC = 10,
  TimeInForce_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TimeInForce_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TimeInForce_IsValid(int value);
const TimeInForce TimeInForce_MIN = ATC;
const TimeInForce TimeInForce_MAX = AUC;
const int TimeInForce_ARRAYSIZE = TimeInForce_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeInForce_descriptor();
inline const ::std::string& TimeInForce_Name(TimeInForce value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeInForce_descriptor(), value);
}
inline bool TimeInForce_Parse(
    const ::std::string& name, TimeInForce* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeInForce>(
    TimeInForce_descriptor(), name, value);
}
enum BusinessType {
  BUSINESS_TYPE_UNDEFINED = 0,
  FUTURE = 1,
  STOCK = 2,
  OPTION = 3,
  BusinessType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BusinessType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BusinessType_IsValid(int value);
const BusinessType BusinessType_MIN = BUSINESS_TYPE_UNDEFINED;
const BusinessType BusinessType_MAX = OPTION;
const int BusinessType_ARRAYSIZE = BusinessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BusinessType_descriptor();
inline const ::std::string& BusinessType_Name(BusinessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BusinessType_descriptor(), value);
}
inline bool BusinessType_Parse(
    const ::std::string& name, BusinessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BusinessType>(
    BusinessType_descriptor(), name, value);
}
enum PositionSide {
  LONG = 0,
  SHORT = 1,
  PositionSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PositionSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PositionSide_IsValid(int value);
const PositionSide PositionSide_MIN = LONG;
const PositionSide PositionSide_MAX = SHORT;
const int PositionSide_ARRAYSIZE = PositionSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionSide_descriptor();
inline const ::std::string& PositionSide_Name(PositionSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionSide_descriptor(), value);
}
inline bool PositionSide_Parse(
    const ::std::string& name, PositionSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionSide>(
    PositionSide_descriptor(), name, value);
}
enum HedgeFlagType {
  SPECULATION = 0,
  ARBITRAGE = 1,
  HEDGE = 2,
  COVERED = 3,
  MARKETMAKER = 4,
  HedgeFlagType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HedgeFlagType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HedgeFlagType_IsValid(int value);
const HedgeFlagType HedgeFlagType_MIN = SPECULATION;
const HedgeFlagType HedgeFlagType_MAX = MARKETMAKER;
const int HedgeFlagType_ARRAYSIZE = HedgeFlagType_MAX + 1;

const ::google::protobuf::EnumDescriptor* HedgeFlagType_descriptor();
inline const ::std::string& HedgeFlagType_Name(HedgeFlagType value) {
  return ::google::protobuf::internal::NameOfEnum(
    HedgeFlagType_descriptor(), value);
}
inline bool HedgeFlagType_Parse(
    const ::std::string& name, HedgeFlagType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HedgeFlagType>(
    HedgeFlagType_descriptor(), name, value);
}
enum OpenCloseType {
  OPEN_CLOSE_TYPE_UNDEFINED = 0,
  OPEN = 1,
  CLOSE = 2,
  CLOSE_TODAY = 3,
  OpenCloseType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpenCloseType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpenCloseType_IsValid(int value);
const OpenCloseType OpenCloseType_MIN = OPEN_CLOSE_TYPE_UNDEFINED;
const OpenCloseType OpenCloseType_MAX = CLOSE_TODAY;
const int OpenCloseType_ARRAYSIZE = OpenCloseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OpenCloseType_descriptor();
inline const ::std::string& OpenCloseType_Name(OpenCloseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OpenCloseType_descriptor(), value);
}
inline bool OpenCloseType_Parse(
    const ::std::string& name, OpenCloseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OpenCloseType>(
    OpenCloseType_descriptor(), name, value);
}
enum InstrumentType {
  INSTRUMENT_TYPE_STOCK = 0,
  INSTRUMENT_TYPE_FUTURE = 1,
  INSTRUMENT_TYPE_OPTION = 2,
  INSTRUMENT_TYPE_FUTURE_OPTION = 3,
  INSTRUMENT_TYPE_BOND = 4,
  INSTRUMENT_TYPE_FX = 5,
  INSTRUMENT_TYPE_INDEX = 6,
  INSTRUMENT_TYPE_ETF = 7,
  INSTRUMENT_TYPE_MULTI_LEG = 8,
  INSTRUMENT_TYPE_SYNTHETIC = 9,
  INSTRUMENT_TYPE_LOF = 10,
  InstrumentType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  InstrumentType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool InstrumentType_IsValid(int value);
const InstrumentType InstrumentType_MIN = INSTRUMENT_TYPE_STOCK;
const InstrumentType InstrumentType_MAX = INSTRUMENT_TYPE_LOF;
const int InstrumentType_ARRAYSIZE = InstrumentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InstrumentType_descriptor();
inline const ::std::string& InstrumentType_Name(InstrumentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InstrumentType_descriptor(), value);
}
inline bool InstrumentType_Parse(
    const ::std::string& name, InstrumentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstrumentType>(
    InstrumentType_descriptor(), name, value);
}
enum IdCardType {
  EID = 0,
  ID_CARD = 1,
  PASSPORT = 2,
  LICENSE_NO = 3,
  TAX_NO = 4,
  DRIVING_LICENSE = 5,
  SOCIAL_ID = 6,
  LOCAL_ID = 7,
  OTHER_CARD = 8,
  IdCardType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  IdCardType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool IdCardType_IsValid(int value);
const IdCardType IdCardType_MIN = EID;
const IdCardType IdCardType_MAX = OTHER_CARD;
const int IdCardType_ARRAYSIZE = IdCardType_MAX + 1;

const ::google::protobuf::EnumDescriptor* IdCardType_descriptor();
inline const ::std::string& IdCardType_Name(IdCardType value) {
  return ::google::protobuf::internal::NameOfEnum(
    IdCardType_descriptor(), value);
}
inline bool IdCardType_Parse(
    const ::std::string& name, IdCardType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IdCardType>(
    IdCardType_descriptor(), name, value);
}
enum ExchangeType {
  EXCHANGETYPE_Undefined = 0,
  SHFE = 1,
  DCE = 2,
  CZCE = 3,
  CFFEX = 4,
  INE = 5,
  SSE = 6,
  SZSE = 7,
  SGE = 8,
  NEEQ = 9,
  HKEx = 10,
  ExchangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExchangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExchangeType_IsValid(int value);
const ExchangeType ExchangeType_MIN = EXCHANGETYPE_Undefined;
const ExchangeType ExchangeType_MAX = HKEx;
const int ExchangeType_ARRAYSIZE = ExchangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExchangeType_descriptor();
inline const ::std::string& ExchangeType_Name(ExchangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExchangeType_descriptor(), value);
}
inline bool ExchangeType_Parse(
    const ::std::string& name, ExchangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExchangeType>(
    ExchangeType_descriptor(), name, value);
}
enum InstLifePhaseType {
  InstLifePhaseType_NotStart = 0,
  InstLifePhaseType_Started = 1,
  InstLifePhaseType_Pause = 2,
  InstLifePhaseType_Expired = 3,
  InstLifePhaseType_Issue = 4,
  InstLifePhaseType_FirstList = 5,
  InstLifePhaseType_UnList = 6,
  InstLifePhaseType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  InstLifePhaseType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool InstLifePhaseType_IsValid(int value);
const InstLifePhaseType InstLifePhaseType_MIN = InstLifePhaseType_NotStart;
const InstLifePhaseType InstLifePhaseType_MAX = InstLifePhaseType_UnList;
const int InstLifePhaseType_ARRAYSIZE = InstLifePhaseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InstLifePhaseType_descriptor();
inline const ::std::string& InstLifePhaseType_Name(InstLifePhaseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InstLifePhaseType_descriptor(), value);
}
inline bool InstLifePhaseType_Parse(
    const ::std::string& name, InstLifePhaseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstLifePhaseType>(
    InstLifePhaseType_descriptor(), name, value);
}
enum TradingPhaseType {
  TradingPhaseType_BeforeTrading = 0,
  TradingPhaseType_NoTrading = 1,
  TradingPhaseType_Continuous = 2,
  TradingPhaseType_AuctionOrdering = 3,
  TradingPhaseType_AuctionBalance = 4,
  TradingPhaseType_AuctionMatch = 5,
  TradingPhaseType_Closed = 6,
  TradingPhaseType_Suspension = 7,
  TradingPhaseType_Fuse = 8,
  TradingPhaseType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TradingPhaseType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TradingPhaseType_IsValid(int value);
const TradingPhaseType TradingPhaseType_MIN = TradingPhaseType_BeforeTrading;
const TradingPhaseType TradingPhaseType_MAX = TradingPhaseType_Fuse;
const int TradingPhaseType_ARRAYSIZE = TradingPhaseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingPhaseType_descriptor();
inline const ::std::string& TradingPhaseType_Name(TradingPhaseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingPhaseType_descriptor(), value);
}
inline bool TradingPhaseType_Parse(
    const ::std::string& name, TradingPhaseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingPhaseType>(
    TradingPhaseType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace FIRST

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::FIRST::ConnectionStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::ConnectionStatus>() {
  return ::FIRST::ConnectionStatus_descriptor();
}
template <> struct is_proto_enum< ::FIRST::ApiType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::ApiType>() {
  return ::FIRST::ApiType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::ResumeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::ResumeType>() {
  return ::FIRST::ResumeType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::LogLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::LogLevel>() {
  return ::FIRST::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::FIRST::PutCall> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::PutCall>() {
  return ::FIRST::PutCall_descriptor();
}
template <> struct is_proto_enum< ::FIRST::OrderStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::OrderStatus>() {
  return ::FIRST::OrderStatus_descriptor();
}
template <> struct is_proto_enum< ::FIRST::ExecType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::ExecType>() {
  return ::FIRST::ExecType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::OrderSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::OrderSide>() {
  return ::FIRST::OrderSide_descriptor();
}
template <> struct is_proto_enum< ::FIRST::OrderType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::OrderType>() {
  return ::FIRST::OrderType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::TimeInForce> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::TimeInForce>() {
  return ::FIRST::TimeInForce_descriptor();
}
template <> struct is_proto_enum< ::FIRST::BusinessType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::BusinessType>() {
  return ::FIRST::BusinessType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::PositionSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::PositionSide>() {
  return ::FIRST::PositionSide_descriptor();
}
template <> struct is_proto_enum< ::FIRST::HedgeFlagType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::HedgeFlagType>() {
  return ::FIRST::HedgeFlagType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::OpenCloseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::OpenCloseType>() {
  return ::FIRST::OpenCloseType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::InstrumentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::InstrumentType>() {
  return ::FIRST::InstrumentType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::IdCardType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::IdCardType>() {
  return ::FIRST::IdCardType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::ExchangeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::ExchangeType>() {
  return ::FIRST::ExchangeType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::InstLifePhaseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::InstLifePhaseType>() {
  return ::FIRST::InstLifePhaseType_descriptor();
}
template <> struct is_proto_enum< ::FIRST::TradingPhaseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FIRST::TradingPhaseType>() {
  return ::FIRST::TradingPhaseType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_enum_2eproto__INCLUDED
